---
import ElevationProfile from "./ElevationProfile.tsx";

interface Props {
  gpxUrl?: string;
  gpxUrls?: string[];
  center?: [number, number];
  zoom?: number;
  showElevationProfile?: boolean;
}

const {
  gpxUrl,
  gpxUrls,
  center = [-122.4194, 37.7749],
  zoom = 13,
  showElevationProfile = true,
} = Astro.props;

// Normalize to array - supports both single gpxUrl and gpxUrls array
const allGpxUrls = gpxUrls ?? (gpxUrl ? [gpxUrl] : []);
// Generate a unique ID for this MapViewer instance
const mapId = `map-viewer-${Math.random().toString(36).substring(2, 9)}`;
---

<figure>
  <!-- Map container -->
  <div
    id={mapId}
    data-gpx-urls={JSON.stringify(allGpxUrls)}
    data-center={JSON.stringify(center)}
    data-zoom={zoom}
  >
  </div>
  <!-- Elevation profile and caption -->
  <div>
    {
      allGpxUrls.length > 0 && showElevationProfile && (
        <ElevationProfile
          gpxUrls={allGpxUrls}
          mapContainerId={mapId}
          client:load
        />
      )
    }
    <figcaption>
      {
        allGpxUrls.length > 0 && (
          <>
            {allGpxUrls.map((url, i) => (
              <>
                <a href={url} download>
                  GPX{allGpxUrls.length > 1 ? ` ${i + 1}` : ""} ↓
                </a>
                {i < allGpxUrls.length - 1 ? " · " : " · "}
              </>
            ))}
          </>
        )
      }
      Map data from <a href="https://www.openstreetmap.org/copyright"
        >OpenStreetMap</a
      > contributors. Tiles by <a href="https://www.maptiler.com/">MapTiler</a>.
      Rendered with <a href="https://maplibre.org/">MapLibre</a>.
    </figcaption>
  </div>
</figure>

<style>
  figure {
    width: 100%;
    margin: 2.5rem 0;

    display: flex;
    flex-direction: column;
    gap: 0.5rem;

    figcaption {
      font-size: 12px;
      color: #666;
      /* text-align: center; */
      /* margin-top: 10px;  */
    }
  }
  [id^="map-viewer-"] {
    width: 100%;
    height: 400px;
  }
</style>

<script>
  import maplibregl from "maplibre-gl";
  import "maplibre-gl/dist/maplibre-gl.css";

  const apiKey = import.meta.env.PUBLIC_MAPTILER_API_KEY;

  // Find all map containers instead of just one
  const mapContainers = document.querySelectorAll('[id^="map-viewer-"]');

  if (!apiKey) {
    console.error(
      "MapTiler API key is not set. Please add PUBLIC_MAPTILER_API_KEY to your .env file"
    );
    mapContainers.forEach((mapContainer) => {
      mapContainer.innerHTML =
        '<div style="padding: 20px; text-align: center; color: #666;">MapTiler API key is not configured. Please add PUBLIC_MAPTILER_API_KEY to your .env file.</div>';
    });
  } else {
    // Initialize each map container
    mapContainers.forEach((mapContainer) => {
      const centerAttr = mapContainer.getAttribute("data-center");
      const zoomAttr = mapContainer.getAttribute("data-zoom");
      const defaultCenter = centerAttr
        ? JSON.parse(centerAttr)
        : [-122.4194, 37.7749];
      const defaultZoom = zoomAttr ? parseInt(zoomAttr, 10) : 13;
      const gpxUrlsAttr = mapContainer.getAttribute("data-gpx-urls");
      const gpxUrls: string[] = gpxUrlsAttr ? JSON.parse(gpxUrlsAttr) : [];

      // Helper function to calculate bounds from track points
      const calculateBounds = (
        trackPoints: [number, number][]
      ): [[number, number], [number, number]] => {
        return trackPoints.reduce(
          (acc, coord) => {
            return [
              [Math.min(acc[0][0], coord[0]), Math.min(acc[0][1], coord[1])],
              [Math.max(acc[1][0], coord[0]), Math.max(acc[1][1], coord[1])],
            ] as [[number, number], [number, number]];
          },
          [
            [trackPoints[0][0], trackPoints[0][1]],
            [trackPoints[0][0], trackPoints[0][1]],
          ] as [[number, number], [number, number]]
        );
      };

      // Helper function to get center from bounds
      const getCenterFromBounds = (
        bounds: [[number, number], [number, number]]
      ) => {
        return [
          (bounds[0][0] + bounds[1][0]) / 2,
          (bounds[0][1] + bounds[1][1]) / 2,
        ] as [number, number];
      };

      // Track colors for multiple GPX files
      const trackColors = [
        "#ff0000",
        "#0066ff",
        "#00aa44",
        "#ff6600",
        "#9900cc",
      ];

      // Initialize map - if GPX URLs are provided, fetch and parse them first
      const initializeMap = async () => {
        let initialCenter = defaultCenter;
        let initialZoom = defaultZoom;
        let allTrackPoints: [number, number][] = [];

        // Store segments per GPX file for rendering
        const allTracks: { segments: [number, number][][]; color: string }[] =
          [];

        // Load all GPX files
        for (let i = 0; i < gpxUrls.length; i++) {
          try {
            const response = await fetch(gpxUrls[i]);
            const gpxText = await response.text();

            // Parse GPX - handle multiple tracks/segments separately
            const parser = new DOMParser();
            const gpxDoc = parser.parseFromString(gpxText, "text/xml");

            // Get all track segments (each <trkseg> becomes a separate line)
            const trackSegments: [number, number][][] = [];
            const segments = gpxDoc.querySelectorAll("trkseg");
            segments.forEach((seg) => {
              const segmentPoints: [number, number][] = Array.from(
                seg.querySelectorAll("trkpt")
              ).map((pt) => {
                const lat = parseFloat(pt.getAttribute("lat") || "0");
                const lon = parseFloat(pt.getAttribute("lon") || "0");
                return [lon, lat];
              });
              if (segmentPoints.length > 0) {
                trackSegments.push(segmentPoints);
              }
            });

            if (trackSegments.length > 0) {
              allTracks.push({
                segments: trackSegments,
                color: trackColors[i % trackColors.length],
              });
              // Add to all points for bounds calculation
              allTrackPoints = allTrackPoints.concat(trackSegments.flat());
            }
          } catch (error) {
            console.error(`Error loading GPX file ${gpxUrls[i]}:`, error);
          }
        }

        if (allTrackPoints.length > 0) {
          // Calculate bounds and center from all GPX tracks
          const bounds = calculateBounds(allTrackPoints);
          initialCenter = getCenterFromBounds(bounds);
          initialZoom = 13;
        }

        // Create map with the calculated center
        const map = new maplibregl.Map({
          container: mapContainer.id,
          style: `https://api.maptiler.com/maps/outdoor/style.json?key=${apiKey}`,
          center: initialCenter,
          zoom: initialZoom,
          interactive: false, // Disables all interactions
          boxZoom: false,
          dragRotate: false,
          dragPan: false,
          doubleClickZoom: false,
          keyboard: false,
          scrollZoom: false,
          touchZoomRotate: false,
          attributionControl: false,
        });

        // Create a marker for elevation profile hover (hidden initially)
        let hoverMarker: maplibregl.Marker | null = null;

        // Listen for elevation hover events
        mapContainer.addEventListener("elevation-hover", ((
          e: CustomEvent<{ lon: number; lat: number } | null>
        ) => {
          if (e.detail) {
            if (!hoverMarker) {
              const el = document.createElement("div");
              el.style.width = "12px";
              el.style.height = "12px";
              el.style.backgroundColor = "#ff0000";
              el.style.borderRadius = "50%";
              el.style.border = "2px solid white";
              el.style.boxShadow = "0 1px 3px rgba(0,0,0,0.3)";
              hoverMarker = new maplibregl.Marker({ element: el });
            }
            hoverMarker.setLngLat([e.detail.lon, e.detail.lat]).addTo(map);
          } else if (hoverMarker) {
            hoverMarker.remove();
          }
        }) as EventListener);

        // If we have GPX tracks, add them to the map
        if (allTracks.length > 0) {
          map.on("load", () => {
            // Add each track as a separate source/layer with its own color
            allTracks.forEach((track, index) => {
              const sourceId = `gpx-track-${index}`;
              const layerId = `gpx-track-layer-${index}`;
              const arrowsLayerId = `gpx-track-arrows-${index}`;

              map.addSource(sourceId, {
                type: "geojson",
                data: {
                  type: "Feature",
                  properties: {},
                  geometry: {
                    type: "MultiLineString",
                    coordinates: track.segments,
                  },
                },
              });

              map.addLayer({
                id: layerId,
                type: "line",
                source: sourceId,
                layout: {
                  "line-join": "round",
                  "line-cap": "round",
                },
                paint: {
                  "line-color": track.color,
                  "line-width": 4,
                  "line-opacity": 0.9,
                },
              });

              // Add directional chevrons along the track
              const chevronSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="0 0 12 12">
                <path d="M2 1 L6 6 L2 11" fill="none" stroke="#ffffff" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
                <path d="M6 1 L10 6 L6 11" fill="none" stroke="#ffffff" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"/>
              </svg>`;
              const chevronImg = new Image(12, 12);
              const imageId = `direction-chevrons-${index}`;
              chevronImg.onload = () => {
                map.addImage(imageId, chevronImg);
                map.addLayer({
                  id: arrowsLayerId,
                  type: "symbol",
                  source: sourceId,
                  layout: {
                    "symbol-placement": "line",
                    "symbol-spacing": 20,
                    "icon-image": imageId,
                    "icon-size": 0.5,
                    "icon-allow-overlap": true,
                    "icon-rotation-alignment": "map",
                  },
                });
              };
              chevronImg.src = `data:image/svg+xml;base64,${btoa(chevronSvg)}`;
            });

            // Fit map to all GPX tracks bounds without animation
            const bounds = calculateBounds(allTrackPoints);
            map.fitBounds(bounds, {
              padding: 50,
              duration: 0,
            });
          });
        }
      };

      initializeMap();
    });
  }
</script>
